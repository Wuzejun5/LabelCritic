# Author: Qilong Wu
# Institute: JHU CCVL, NUS
# Description: This is self-defined data loader for M3D model 4x faster version.

#############################################################################
import os, torch
import nibabel as nib
import numpy as np
import monai.transforms as mtf
from monai.data.meta_tensor import MetaTensor

class CTImageProcessor:
    def __init__(self, case_path, ct_name='ct', mask_name='liver', mask_path=None):
        """
        Initialize the CTImageProcessor class, loading the CT image and retaining the affine and header information.
        
        Parameters:
        - ct_file: Path to the CT image NIfTI file
        """
        self.case_path = case_path
        self.ct_name = ct_name
        self.mask_name = mask_name

        # Use MONAI's LoadImage transform for optimized image loading
        loader = mtf.LoadImage(image_only=False, dtype=np.float32)
        
        # Load the CT image
        try:
            ct_path = os.path.join(case_path, f"{ct_name}.nii.gz")
            # print(f"Attempting to load CT image from: {ct_path}")
            self.ct_image_data, meta_data = loader(ct_path)
            self.affine = meta_data['affine']
        except FileNotFoundError:
            case = os.path.basename(case_path)
            ct_path = os.path.join("/mnt/T9/AbdomenAtlasPro", case, f"{ct_name}.nii.gz")
            # print(f"First path failed, trying alternative path: {ct_path}")
            self.ct_image_data, meta_data = loader(ct_path)
            self.affine = meta_data['affine']
        except Exception as e:
            print(f"Failed to load CT image from {ct_path}: {e}")
            raise

        # Load the mask
        if mask_path:
            case_path = mask_path
        if mask_name == "kidneys":
            mask1_path = os.path.join(case_path, "segmentations", "kidney_left.nii.gz")
            mask2_path = os.path.join(case_path, "segmentations", "kidney_right.nii.gz")
            mask1_data, _ = loader(mask1_path)
            mask2_data, _ = loader(mask2_path)
            if isinstance(mask1_data, list):
                mask1_data = mask1_data[0]
            if isinstance(mask2_data, list):
                mask2_data = mask2_data[0]
            mask1_data = np.array(mask1_data)
            mask2_data = np.array(mask2_data)
            self.mask_data = np.maximum(mask1_data, mask2_data)
            del mask1_data, mask2_data
        else:
            mask_path = os.path.join(case_path, "segmentations", f"{mask_name}.nii.gz")
            mask_data, _ = loader(mask_path)
            if isinstance(mask_data, list):
                mask_data = mask_data[0]
            self.mask_data = np.array(mask_data)
            del mask_data

        # Add channel dimension
        self.ct_image_data = np.expand_dims(self.ct_image_data, axis=0)
        self.mask_data = np.expand_dims(self.mask_data, axis=0)

        # Create MetaTensor objects
        self.ct_image = MetaTensor(self.ct_image_data, affine=self.affine)
        self.ct_mask = MetaTensor(self.mask_data, affine=self.affine)

        self.transformed = None
        self.transforms = None
        self.apply_transforms()

        self.ctmin_image = None
        self.get_ctmin()
        self.ctmin_transformed = None
        ctmin_pair = {"image": self.ctmin_image, "seg": self.ct_mask}
        self.ctmin_transformed = self.transforms(ctmin_pair)

        self.mask_present = not np.all(self.mask_data == 0)

    def get_ctmin(self):
        # Set the values within the mask to the minimum value of the CT image
        ct_data = self.ct_image_data.copy()
        ct_data[self.mask_data == 1] = ct_data.min()
        self.ctmin_image = MetaTensor(ct_data, affine=self.affine)
        del ct_data

    def apply_transforms(self):
        """
        Apply specified transformations to the CT image and return the transformed image and transform object.
        """
        # Define the transformations
        self.transforms = mtf.Compose([
            mtf.ScaleIntensityRangePercentilesd(
                keys=["image"], lower=0.5, upper=99.5, b_min=0.0, b_max=1.0, clip=True
            ),
            mtf.CropForegroundd(
                keys=["image", "seg"],
                source_key="image"
            ),
            mtf.Resized(
                keys=["image", "seg"],
                spatial_size=[32, 256, 256],
                mode=['trilinear', 'nearest']
            ),
        ])

        # Apply transformations
        pair = {"image": self.ct_image, "seg": self.ct_mask}
        self.transformed = self.transforms(pair)
        
    def invert_mask(self, predicted_mask, output_path, get_noninver=False):
        """
        Apply inverse transformation to the predicted mask and save it as a NIfTI file.
        
        Parameters:
        - predicted_mask: Segmentation mask generated by the model
        - output_path: Path to save the inverse-transformed mask
        """
        # Apply inverse transformations to the predicted mask
        with mtf.allow_missing_keys_mode(self.transforms):
            inverted = self.transforms.inverse(
                {"image": self.transformed["image"], "seg": predicted_mask}
            )
        
        # Adjust dimension order [depth, height, width] -> [height, width, depth]
        inverted_mask = inverted["seg"].squeeze().permute(1, 2, 0).cpu().numpy()
        # Convert mask to uint8 and binarize
        inverted_mask = (inverted_mask > 0.5).astype(np.uint8)
        # Create a new NIfTI image object and save it
        nib.save(
            nib.Nifti1Image(inverted_mask, affine=self.affine, header=self.header), 
            output_path
        )
        print(f"Inverted mask saved to {output_path}")
        if get_noninver:
            nib.save(
                nib.Nifti1Image(predicted_mask.squeeze().permute(1, 2, 0).cpu().numpy(), 
                                affine=self.affine, header=self.header), 
                output_path.split(".")[0] + "_tf.nii.gz"
            )
            print(f"Non-inverted mask saved to {output_path.split('.nii.gz')[0] + '_tf.nii.gz'}")
    
    def save_transformed(self, output_path="."):
        if self.transformed is None:
            raise ValueError("Please apply transforms first before calling save_transformed.")
        transformed_image = self.transformed["image"].squeeze().permute(1, 2, 0).cpu().numpy()
        transformed_mask = self.transformed["seg"].squeeze().permute(1, 2, 0).cpu().numpy()
        
        # Save the NIfTI file
        nib.save(
            nib.Nifti1Image(transformed_image, affine=self.affine, header=self.header), 
            os.path.join(output_path, f"{self.ct_name}_tf.nii.gz")
        )
        nib.save(
            nib.Nifti1Image(transformed_mask, affine=self.affine, header=self.header), 
            os.path.join(output_path, f"{self.ct_name}_{self.mask_name}_tf.nii.gz")
        )
        print(f"Transformed image saved to {output_path}")
